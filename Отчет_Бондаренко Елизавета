Постановка задачи
Напечатать в порядке возрастания первых n натуральных чисел, в разложение которых на простые множители входят только числа 2,3,5. 
Идея решения: введем три очереди x2, x3, x5 в которых будем хранить элементы, которые соответственно в 2, 3, 5 раз больше напечатанных, но еще не напечатаны. Рассмотрим наименьший из ненапечатанных элементов: пусть это x. Тогда он делится нацело на одно из чисел 2, 3, 5; x находится в одной из очередей и является в ней первым элементом (меньшие его уже напечатаны, а элементы очередей не напечатаны). Напечатав x, нужно изъять его из очереди и добавить в очередь кратные ему элементы. Длины очередей не превосходят числа напечатанных элементов. Изначально в очередях хранится по одному числу.
 
Алгоритм решения

Нужно найти первые n чисел, которые можно получить, умножая только на 2, 3 и 5. Эти числа называют уродливыми. Например, 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 и так далее. Число 1 считается уродливым по определению.
1.	Начинаем с числа 1.
Мы считаем, что 1 — это первое уродливое число. Создаём список, куда положим это число.
2.	Создаём три очереди.
Очередь — это такой список, где мы можем быстро добавлять числа в конец и быстро брать числа с начала.
o	Первая очередь — q2. В ней будут числа, которые нужно умножать на 2. Сначала туда положим 2 (потому что 1 * 2 = 2).
o	Вторая очередь — q3. Там будут числа для умножения на 3. Положим туда 3 (1 * 3 = 3).
o	Третья очередь — q5. Там будут числа для умножения на 5. Положим туда 5 (1 * 5 = 5).
3.	Выбираем следующее уродливое число.
Мы смотрим на первые числа из всех трёх очередей (то есть первые элементы в q2, q3 и q5) и выбираем самое маленькое из них. Это число добавляем в наш список уродливых чисел.
4.	Удаляем это число из всех очередей, где оно есть.
Если выбранное число стоит одновременно в нескольких очередях, то нужно его удалить отовсюду, чтобы не получить повтор в списке.
5.	Добавляем новые числа в очереди.
После того, как мы добавили новое число в список, берём это число и умножаем на 2, 3 и 5. Результаты кладём в очереди q2, q3 и q5 соответственно. Это новые кандидаты для следующих уродливых чисел.
6.	Повторяем шаги 3-5.
Продолжаем делать это, пока в нашем списке не будет нужного количества — n чисел.
•	Мы всегда берём самое маленькое число из всех возможных вариантов. Значит, числа в списке идут по возрастанию.
•	Удаляем повторы, чтобы не дублировать числа.
•	Постоянно добавляем новые числа — умножаем на 2, 3 и 5, так мы не пропустим ни одного уродливого числа.

Используемые структуры данных
•	Односвязный список для результата.
Это структура, где мы можем легко добавлять числа в конец, не зная заранее, сколько их будет. Потом легко пройтись по списку и вывести все числа.
•	Очереди на основе односвязных списков для q2, q3 и q5.
Очередь нужна, чтобы быстро брать число с начала и добавлять в конец, чтобы алгоритм работал быстро и эффективно.
•	Целые числа.
Все числа — обычные целые, так как мы работаем с натуральными числами.
1. Класс Node
Класс Node — это один элемент связного списка. Он хранит:
•	Число, которое мы хотим сохранить.
•	Ссылку на следующий такой же элемент (узел).
С помощью таких узлов строится список, в который мы добавляем найденные уродливые числа. Каждый элемент знает, кто идёт за ним.

2. Класс Queue
Класс Queue — это очередь. Она работает так: что добавили раньше — то и обрабатывается раньше. Внутри она построена с помощью узлов Node, как связный список.
У неё есть:
•	front — откуда забираем элемент.
•	rear — куда добавляем новый элемент.
Методы:
•	enqueue(value) — добавить число в конец очереди.
•	dequeue() — удалить и вернуть число из начала очереди.
•	peek() — просто посмотреть, какое число в начале, не удаляя его.
•	is_empty() — проверить, пустая ли очередь.
Такие очереди мы используем для хранения чисел, которые нужно умножать на 2, 3 и 5.

3. Класс UglyNumberGenerator
Этот класс создаёт список чисел, которые можно получить умножением только на 2, 3 или 5.
В нём есть:
•	Сколько чисел надо найти (count).
•	Начальный список, в котором уже есть 1.
•	Три очереди:
o	q2 — числа для умножения на 2,
o	q3 — на 3,
o	q5 — на 5.
Сначала в очередях:
•	q2 = [2],
•	q3 = [3],
•	q5 = [5].
Дальше работает цикл:
1.	Смотрим по одному числу из каждой очереди (самые первые).
2.	Берём минимальное.
3.	Добавляем его в список.
4.	Удаляем его из всех очередей, где оно встречается.
5.	Умножаем это число на 2, 3 и 5 и кладём обратно в очереди.
Так повторяется, пока мы не найдём нужное количество чисел.
Методы:
•	generate() — запускает весь процесс.
•	append_result(value) — добавляет число в конец списка.
•	get_result_length() — возвращает, сколько чисел уже найдено.
•	get_result_list() — переводит наш связный список в обычный список Python.
4. Класс UserInterface
Это просто интерфейс для пользователя. Он:
•	Просит ввести, сколько чисел нужно.
•	Проверяет, что введено правильно.
•	Запускает генератор.
•	Показывает результат.
•	Если была ошибка — сообщает об этом.






Тестирование
# генератор чисел, содержащих только множители 2, 3 и 5.
# введите количество чисел (>0): 10
# результат:
# [1, 2, 3, 4, 5, 6, 8, 9, 10, 12]

# генератор чисел, содержащих только множители 2, 3 и 5.
# введите количество чисел (>0): 1
# результат:
# [1]

# генератор чисел, содержащих только множители 2, 3 и 5.
# введите количество чисел (>0): 15
# результат:
# [1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24]

# генератор чисел, содержащих только множители 2, 3 и 5.
# введите количество чисел (>0): 0
# ошибка: число должно быть больше нуля.
# введите количество чисел (>0):  
# ошибка: введите положительное целое число.
# введите количество чисел (>0): -4
# ошибка: введите положительное целое число.
# введите количество чисел (>0): ра 

Код программы
class Node:
    # класс узла односвязного списка
    # хранит значение и ссылку на следующий узел
    def __init__(self, value):
        self.value = value  # число или данные, которые храним в узле
        self.next = None    # ссылка на следующий узел (изначально None)


class Queue:
    # класс очереди на базе односвязного списка
    # поддерживает операции добавления в конец и удаления из начала за O(1)
    def __init__(self):
        self.front = None  # начало очереди — элемент, который будет извлечён первым
        self.rear = None   # конец очереди — элемент, в который мы добавляем новые данные

    def enqueue(self, value):
        # добавляет новый элемент в конец очереди
        new_node = Node(value)
        if self.rear is None:
            # если очередь пустая, новый узел — и начало, и конец
            self.front = new_node
        else:
            # если очередь не пустая, связать последний узел с новым
            self.rear.next = new_node
        self.rear = new_node  # обновить указатель на конец очереди

    def dequeue(self):
        # удаляет и возвращает элемент из начала очереди
        if self.is_empty():
            raise Exception("ошибка: попытка извлечь из пустой очереди")
        value = self.front.value
        self.front = self.front.next  # сдвигаем начало очереди
        if self.front is None:
            # если очередь стала пустой, обнуляем и конец
            self.rear = None
        return value

    def peek(self):
        # возвращает значение первого элемента очереди без удаления
        if self.is_empty():
            raise Exception("ошибка: очередь пуста")
        return self.front.value

    def is_empty(self):
        # проверяет, пуста ли очередь
        return self.front is None


class UglyNumberGenerator:
    # класс для генерации первых n уродливых чисел
    # использует три очереди для управления кандидатами на умножение на 2, 3 и 5
    def __init__(self, count):
        self.count = count  # сколько уродливых чисел нужно сгенерировать
        self.result_head = Node(1)  # связный список с первым уродливым числом 1

        # создаём очереди для чисел, которые будут умножаться на 2, 3 и 5
        self.q2 = Queue()
        self.q3 = Queue()
        self.q5 = Queue()

        # помещаем начальные значения в очереди (1*2, 1*3, 1*5)
        self.q2.enqueue(2)
        self.q3.enqueue(3)
        self.q5.enqueue(5)

    def get_result_length(self):
        # считает количество элементов в списке результатов
        count = 0
        current = self.result_head
        while current is not None:
            count += 1
            current = current.next
        return count

    def append_result(self, value):
        # добавляет новое уродливое число в конец связного списка результатов
        current = self.result_head
        while current.next is not None:
            current = current.next
        current.next = Node(value)

    def get_min(self, a, b, c):
        # возвращает минимальное из трёх чисел — чтобы выбрать следующее уродливое число
        min_val = a
        if b < min_val:
            min_val = b
        if c < min_val:
            min_val = c
        return min_val

    def generate(self):
        # основной алгоритм генерации уродливых чисел
        while self.get_result_length() < self.count:
            v2 = self.q2.peek()
            v3 = self.q3.peek()
            v5 = self.q5.peek()

            next_val = self.get_min(v2, v3, v5)  # выбираем минимальное число
            self.append_result(next_val)  # добавляем его в список результатов

            # удаляем число из всех очередей, где оно встречается, чтобы не было дублей
            if next_val == v2:
                self.q2.dequeue()
            if next_val == v3:
                self.q3.dequeue()
            if next_val == v5:
                self.q5.dequeue()

            # добавляем новые числа, умножая next_val на 2, 3 и 5
            self.q2.enqueue(next_val * 2)
            self.q3.enqueue(next_val * 3)
            self.q5.enqueue(next_val * 5)

    def get_result_list(self):
        # превращает связный список уродливых чисел в обычный список Python для удобного вывода
        values = []
        current = self.result_head
        while current is not None:
            values.append(current.value)
            current = current.next
        return values


class UserInterface: # класс для взаимодействия с пользователем
    # запрашивает количество чисел, запускает генератор и выводит результат
    def run(self):
        print("генератор чисел, содержащих только множители 2, 3 и 5.")
        while True:
            try:
                n_str = input("введите количество чисел (>0): ")
                if not n_str.isdigit():
                    raise ValueError("введите положительное целое число.")
                n = int(n_str)
                if n <= 0:
                    raise ValueError("число должно быть больше нуля.")
                generator = UglyNumberGenerator(n)  # создаём генератор
                generator.generate()  # запускаем генерацию чисел
                print("результат:")
                print(generator.get_result_list())  # выводим результат в виде списка
                break
            except Exception as e:
                print("ошибка:", e)


if __name__ == "__main__":
    ui = UserInterface()
    ui.run()

